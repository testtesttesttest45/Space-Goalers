// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  public enum AbilityAvailabilityType : int {
    Always,
    WithBall,
    WithoutBall,
  }
  public enum AbilityType : int {
    Block,
    Dash,
    Attack,
    ThrowShort,
    ThrowLong,
    Jump,
    Hook,
    Invisibility,
    Speedster,
    Banana,
    Bomb,
  }
  public enum GameState : int {
    None,
    Initializing,
    Starting,
    Running,
    GoalScored,
    GameOver,
  }
  public enum PlayerTeam : int {
    Blue,
    Red,
  }
  public enum StatusEffectType : int {
    Stun,
    Knockback,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    _left = 1 << 0,
    _right = 1 << 1,
    _up = 1 << 2,
    _down = 1 << 3,
    _a = 1 << 4,
    _b = 1 << 5,
    _c = 1 << 6,
    _d = 1 << 7,
    _l1 = 1 << 8,
    _l2 = 1 << 9,
    _r1 = 1 << 10,
    _select = 1 << 11,
    _start = 1 << 12,
    _r2 = 1 << 13,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public readonly Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0]);
        result += Maths.CountSetBits(p[1]);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if (p[0] != 0) return true;
        if (p[1] != 0) return true;
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public readonly Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 32; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 32; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public readonly Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0]);
        result += Maths.CountSetBits(p[1]);
        result += Maths.CountSetBits(p[2]);
        result += Maths.CountSetBits(p[3]);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if (p[0] != 0) return true;
        if (p[1] != 0) return true;
        if (p[2] != 0) return true;
        if (p[3] != 0) return true;
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public readonly Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 64; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 64; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public readonly Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 8; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 8; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet6 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 6;
    public readonly Int32 Length {
      get {
        return 6;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet6*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 6, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet6 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet6 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0] & 0x3FUL);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if ((p[0] & 0x3FUL) != 0) return true;
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 13669;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet6*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Ability {
    public const Int32 SIZE = 80;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public AbilityType AbilityType;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public CountdownTimer InputBufferTimer;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public CountdownTimer DelayTimer;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public CountdownTimer DurationTimer;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public CountdownTimer CooldownTimer;
    [FieldOffset(8)]
    public AssetRef<AbilityData> AbilityData;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 6343;
        hash = hash * 31 + (Int32)AbilityType;
        hash = hash * 31 + InputBufferTimer.GetHashCode();
        hash = hash * 31 + DelayTimer.GetHashCode();
        hash = hash * 31 + DurationTimer.GetHashCode();
        hash = hash * 31 + CooldownTimer.GetHashCode();
        hash = hash * 31 + AbilityData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Ability*)ptr;
        serializer.Stream.Serialize((Int32*)&p->AbilityType);
        AssetRef.Serialize(&p->AbilityData, serializer);
        Quantum.CountdownTimer.Serialize(&p->CooldownTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->DelayTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->DurationTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->InputBufferTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ActiveAbilityInfo {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Int32 ActiveAbilityIndex;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FPVector3 CastDirection;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public FPQuaternion CastRotation;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public FPVector3 CastVelocity;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FP CastStrength;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 2017;
        hash = hash * 31 + ActiveAbilityIndex.GetHashCode();
        hash = hash * 31 + CastDirection.GetHashCode();
        hash = hash * 31 + CastRotation.GetHashCode();
        hash = hash * 31 + CastVelocity.GetHashCode();
        hash = hash * 31 + CastStrength.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ActiveAbilityInfo*)ptr;
        serializer.Stream.Serialize(&p->ActiveAbilityIndex);
        FP.Serialize(&p->CastStrength, serializer);
        FPVector3.Serialize(&p->CastDirection, serializer);
        FPVector3.Serialize(&p->CastVelocity, serializer);
        FPQuaternion.Serialize(&p->CastRotation, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CountdownTimer {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP TimeLeft;
    [FieldOffset(0)]
    public FP StartTime;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 8641;
        hash = hash * 31 + TimeLeft.GetHashCode();
        hash = hash * 31 + StartTime.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CountdownTimer*)ptr;
        FP.Serialize(&p->StartTime, serializer);
        FP.Serialize(&p->TimeLeft, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 184;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(88)]
    public Button _left;
    [FieldOffset(124)]
    public Button _right;
    [FieldOffset(160)]
    public Button _up;
    [FieldOffset(52)]
    public Button _down;
    [FieldOffset(4)]
    public Button _a;
    [FieldOffset(16)]
    public Button _b;
    [FieldOffset(28)]
    public Button _c;
    [FieldOffset(40)]
    public Button _d;
    [FieldOffset(64)]
    public Button _l1;
    [FieldOffset(76)]
    public Button _l2;
    [FieldOffset(100)]
    public Button _r1;
    [FieldOffset(136)]
    public Button _select;
    [FieldOffset(148)]
    public Button _start;
    [FieldOffset(112)]
    public Button _r2;
    [FieldOffset(1)]
    public Byte _analogRightTrigger;
    [FieldOffset(0)]
    public Byte _analogLeftTrigger;
    [FieldOffset(172)]
    public QuantumThumbSticks ThumbSticks;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + _left.GetHashCode();
        hash = hash * 31 + _right.GetHashCode();
        hash = hash * 31 + _up.GetHashCode();
        hash = hash * 31 + _down.GetHashCode();
        hash = hash * 31 + _a.GetHashCode();
        hash = hash * 31 + _b.GetHashCode();
        hash = hash * 31 + _c.GetHashCode();
        hash = hash * 31 + _d.GetHashCode();
        hash = hash * 31 + _l1.GetHashCode();
        hash = hash * 31 + _l2.GetHashCode();
        hash = hash * 31 + _r1.GetHashCode();
        hash = hash * 31 + _select.GetHashCode();
        hash = hash * 31 + _start.GetHashCode();
        hash = hash * 31 + _r2.GetHashCode();
        hash = hash * 31 + _analogRightTrigger.GetHashCode();
        hash = hash * 31 + _analogLeftTrigger.GetHashCode();
        hash = hash * 31 + ThumbSticks.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 6;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons._left: return _left.IsDown;
        case InputButtons._right: return _right.IsDown;
        case InputButtons._up: return _up.IsDown;
        case InputButtons._down: return _down.IsDown;
        case InputButtons._a: return _a.IsDown;
        case InputButtons._b: return _b.IsDown;
        case InputButtons._c: return _c.IsDown;
        case InputButtons._d: return _d.IsDown;
        case InputButtons._l1: return _l1.IsDown;
        case InputButtons._l2: return _l2.IsDown;
        case InputButtons._r1: return _r1.IsDown;
        case InputButtons._select: return _select.IsDown;
        case InputButtons._start: return _start.IsDown;
        case InputButtons._r2: return _r2.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons._left: return _left.WasPressed;
        case InputButtons._right: return _right.WasPressed;
        case InputButtons._up: return _up.WasPressed;
        case InputButtons._down: return _down.WasPressed;
        case InputButtons._a: return _a.WasPressed;
        case InputButtons._b: return _b.WasPressed;
        case InputButtons._c: return _c.WasPressed;
        case InputButtons._d: return _d.WasPressed;
        case InputButtons._l1: return _l1.WasPressed;
        case InputButtons._l2: return _l2.WasPressed;
        case InputButtons._r1: return _r1.WasPressed;
        case InputButtons._select: return _select.WasPressed;
        case InputButtons._start: return _start.WasPressed;
        case InputButtons._r2: return _r2.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        serializer.Stream.Serialize(&p->_analogLeftTrigger);
        serializer.Stream.Serialize(&p->_analogRightTrigger);
        Button.Serialize(&p->_a, serializer);
        Button.Serialize(&p->_b, serializer);
        Button.Serialize(&p->_c, serializer);
        Button.Serialize(&p->_d, serializer);
        Button.Serialize(&p->_down, serializer);
        Button.Serialize(&p->_l1, serializer);
        Button.Serialize(&p->_l2, serializer);
        Button.Serialize(&p->_left, serializer);
        Button.Serialize(&p->_r1, serializer);
        Button.Serialize(&p->_r2, serializer);
        Button.Serialize(&p->_right, serializer);
        Button.Serialize(&p->_select, serializer);
        Button.Serialize(&p->_start, serializer);
        Button.Serialize(&p->_up, serializer);
        Quantum.QuantumThumbSticks.Serialize(&p->ThumbSticks, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Quantum.Core.DerivedStructAttribute(typeof(StatusEffect))]
  public unsafe partial struct KnockbackStatusEffect : IDerivedStruct<StatusEffect> {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public CountdownTimer DurationTimer;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public FPVector3 KnockbackDirection;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public FPVector3 KnockbackVelocity;
    [FieldOffset(16)]
    public AssetRef<KnockbackStatusEffectData> StatusEffectData;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 21383;
        hash = hash * 31 + DurationTimer.GetHashCode();
        hash = hash * 31 + KnockbackDirection.GetHashCode();
        hash = hash * 31 + KnockbackVelocity.GetHashCode();
        hash = hash * 31 + StatusEffectData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KnockbackStatusEffect*)ptr;
        Quantum.CountdownTimer.Serialize(&p->DurationTimer, serializer);
        AssetRef.Serialize(&p->StatusEffectData, serializer);
        FPVector3.Serialize(&p->KnockbackDirection, serializer);
        FPVector3.Serialize(&p->KnockbackVelocity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct QuantumDemoInputPlatformer2D {
    public const Int32 SIZE = 136;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(120)]
    public FPVector2 AimDirection;
    [FieldOffset(72)]
    public Button Left;
    [FieldOffset(84)]
    public Button Right;
    [FieldOffset(96)]
    public Button Up;
    [FieldOffset(24)]
    public Button Down;
    [FieldOffset(60)]
    public Button Jump;
    [FieldOffset(12)]
    public Button Dash;
    [FieldOffset(36)]
    public Button Fire;
    [FieldOffset(0)]
    public Button AltFire;
    [FieldOffset(108)]
    public Button Use;
    [FieldOffset(48)]
    public Button Hook;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17191;
        hash = hash * 31 + AimDirection.GetHashCode();
        hash = hash * 31 + Left.GetHashCode();
        hash = hash * 31 + Right.GetHashCode();
        hash = hash * 31 + Up.GetHashCode();
        hash = hash * 31 + Down.GetHashCode();
        hash = hash * 31 + Jump.GetHashCode();
        hash = hash * 31 + Dash.GetHashCode();
        hash = hash * 31 + Fire.GetHashCode();
        hash = hash * 31 + AltFire.GetHashCode();
        hash = hash * 31 + Use.GetHashCode();
        hash = hash * 31 + Hook.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumDemoInputPlatformer2D*)ptr;
        Button.Serialize(&p->AltFire, serializer);
        Button.Serialize(&p->Dash, serializer);
        Button.Serialize(&p->Down, serializer);
        Button.Serialize(&p->Fire, serializer);
        Button.Serialize(&p->Hook, serializer);
        Button.Serialize(&p->Jump, serializer);
        Button.Serialize(&p->Left, serializer);
        Button.Serialize(&p->Right, serializer);
        Button.Serialize(&p->Up, serializer);
        Button.Serialize(&p->Use, serializer);
        FPVector2.Serialize(&p->AimDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct QuantumDemoInputShooter3D {
    public const Int32 SIZE = 104;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(88)]
    public FPVector2 MoveDirection;
    [FieldOffset(0)]
    public FP Pitch;
    [FieldOffset(8)]
    public FP Yaw;
    [FieldOffset(64)]
    public Button Jump;
    [FieldOffset(28)]
    public Button Dash;
    [FieldOffset(40)]
    public Button Fire;
    [FieldOffset(16)]
    public Button AltFire;
    [FieldOffset(76)]
    public Button Use;
    [FieldOffset(52)]
    public Button Hook;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 15511;
        hash = hash * 31 + MoveDirection.GetHashCode();
        hash = hash * 31 + Pitch.GetHashCode();
        hash = hash * 31 + Yaw.GetHashCode();
        hash = hash * 31 + Jump.GetHashCode();
        hash = hash * 31 + Dash.GetHashCode();
        hash = hash * 31 + Fire.GetHashCode();
        hash = hash * 31 + AltFire.GetHashCode();
        hash = hash * 31 + Use.GetHashCode();
        hash = hash * 31 + Hook.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumDemoInputShooter3D*)ptr;
        FP.Serialize(&p->Pitch, serializer);
        FP.Serialize(&p->Yaw, serializer);
        Button.Serialize(&p->AltFire, serializer);
        Button.Serialize(&p->Dash, serializer);
        Button.Serialize(&p->Fire, serializer);
        Button.Serialize(&p->Hook, serializer);
        Button.Serialize(&p->Jump, serializer);
        Button.Serialize(&p->Use, serializer);
        FPVector2.Serialize(&p->MoveDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct QuantumDemoInputTopDown {
    public const Int32 SIZE = 208;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(192)]
    public FPVector2 MoveDirection;
    [FieldOffset(160)]
    public FPVector2 AimDirection;
    [FieldOffset(176)]
    public FPVector2 DropzoneDir01;
    [FieldOffset(0)]
    public QBoolean DropzoneHas;
    [FieldOffset(88)]
    public Button Left;
    [FieldOffset(100)]
    public Button Right;
    [FieldOffset(136)]
    public Button Up;
    [FieldOffset(40)]
    public Button Down;
    [FieldOffset(76)]
    public Button Jump;
    [FieldOffset(28)]
    public Button Dash;
    [FieldOffset(52)]
    public Button Fire;
    [FieldOffset(4)]
    public Button AltFire;
    [FieldOffset(148)]
    public Button Use;
    [FieldOffset(64)]
    public Button Hook;
    [FieldOffset(124)]
    public Button Speed;
    [FieldOffset(112)]
    public Button Select;
    [FieldOffset(16)]
    public Button Bomb;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 5501;
        hash = hash * 31 + MoveDirection.GetHashCode();
        hash = hash * 31 + AimDirection.GetHashCode();
        hash = hash * 31 + DropzoneDir01.GetHashCode();
        hash = hash * 31 + DropzoneHas.GetHashCode();
        hash = hash * 31 + Left.GetHashCode();
        hash = hash * 31 + Right.GetHashCode();
        hash = hash * 31 + Up.GetHashCode();
        hash = hash * 31 + Down.GetHashCode();
        hash = hash * 31 + Jump.GetHashCode();
        hash = hash * 31 + Dash.GetHashCode();
        hash = hash * 31 + Fire.GetHashCode();
        hash = hash * 31 + AltFire.GetHashCode();
        hash = hash * 31 + Use.GetHashCode();
        hash = hash * 31 + Hook.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + Select.GetHashCode();
        hash = hash * 31 + Bomb.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumDemoInputTopDown*)ptr;
        QBoolean.Serialize(&p->DropzoneHas, serializer);
        Button.Serialize(&p->AltFire, serializer);
        Button.Serialize(&p->Bomb, serializer);
        Button.Serialize(&p->Dash, serializer);
        Button.Serialize(&p->Down, serializer);
        Button.Serialize(&p->Fire, serializer);
        Button.Serialize(&p->Hook, serializer);
        Button.Serialize(&p->Jump, serializer);
        Button.Serialize(&p->Left, serializer);
        Button.Serialize(&p->Right, serializer);
        Button.Serialize(&p->Select, serializer);
        Button.Serialize(&p->Speed, serializer);
        Button.Serialize(&p->Up, serializer);
        Button.Serialize(&p->Use, serializer);
        FPVector2.Serialize(&p->AimDirection, serializer);
        FPVector2.Serialize(&p->DropzoneDir01, serializer);
        FPVector2.Serialize(&p->MoveDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct QuantumHighresThumbSticks {
    public const Int32 SIZE = 6;
    public const Int32 ALIGNMENT = 2;
    [FieldOffset(0)]
    public Byte _leftThumbAngle;
    [FieldOffset(1)]
    public Byte _leftThumbMagnitude;
    [FieldOffset(2)]
    public Int16 _rightThumbX;
    [FieldOffset(4)]
    public Int16 _rightThumbY;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 18181;
        hash = hash * 31 + _leftThumbAngle.GetHashCode();
        hash = hash * 31 + _leftThumbMagnitude.GetHashCode();
        hash = hash * 31 + _rightThumbX.GetHashCode();
        hash = hash * 31 + _rightThumbY.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumHighresThumbSticks*)ptr;
        serializer.Stream.Serialize(&p->_leftThumbAngle);
        serializer.Stream.Serialize(&p->_leftThumbMagnitude);
        serializer.Stream.Serialize(&p->_rightThumbX);
        serializer.Stream.Serialize(&p->_rightThumbY);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct QuantumRegularThumbSticks {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 1;
    [FieldOffset(0)]
    public Byte _leftThumbAngle;
    [FieldOffset(1)]
    public Byte _leftThumbMagnitude;
    [FieldOffset(2)]
    public Byte _rightThumbAngle;
    [FieldOffset(3)]
    public Byte _rightThumbMagnitude;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 2731;
        hash = hash * 31 + _leftThumbAngle.GetHashCode();
        hash = hash * 31 + _leftThumbMagnitude.GetHashCode();
        hash = hash * 31 + _rightThumbAngle.GetHashCode();
        hash = hash * 31 + _rightThumbMagnitude.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumRegularThumbSticks*)ptr;
        serializer.Stream.Serialize(&p->_leftThumbAngle);
        serializer.Stream.Serialize(&p->_leftThumbMagnitude);
        serializer.Stream.Serialize(&p->_rightThumbAngle);
        serializer.Stream.Serialize(&p->_rightThumbMagnitude);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SelectedAbilities {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(8)]
    public AbilityType Utility;
    [FieldOffset(0)]
    public AbilityType Main1;
    [FieldOffset(4)]
    public AbilityType Main2;
    [FieldOffset(12)]
    public QBoolean IsSet;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 18127;
        hash = hash * 31 + (Int32)Utility;
        hash = hash * 31 + (Int32)Main1;
        hash = hash * 31 + (Int32)Main2;
        hash = hash * 31 + IsSet.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SelectedAbilities*)ptr;
        serializer.Stream.Serialize((Int32*)&p->Main1);
        serializer.Stream.Serialize((Int32*)&p->Main2);
        serializer.Stream.Serialize((Int32*)&p->Utility);
        QBoolean.Serialize(&p->IsSet, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct StatusEffect {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public CountdownTimer DurationTimer;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 10399;
        hash = hash * 31 + DurationTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (StatusEffect*)ptr;
        Quantum.CountdownTimer.Serialize(&p->DurationTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Serializable()]
  public unsafe partial struct StatusEffectConfig {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public StatusEffectType Type;
    [FieldOffset(8)]
    public FP Duration;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 9743;
        hash = hash * 31 + (Int32)Type;
        hash = hash * 31 + Duration.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (StatusEffectConfig*)ptr;
        serializer.Stream.Serialize((Int32*)&p->Type);
        FP.Serialize(&p->Duration, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 1768;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(80)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(96)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(112)]
    public RNGSession RngSession;
    [FieldOffset(128)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(176)]
    public BitSet1024 Systems;
    [FieldOffset(304)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(600)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(604)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 6)]
    private fixed Byte _input_[1104];
    [FieldOffset(1712)]
    public BitSet6 PlayerLastConnectionState;
    [FieldOffset(1720)]
    public GameState GameState;
    [FieldOffset(1736)]
    public CountdownTimer GameStateTimer;
    [FieldOffset(1752)]
    public CountdownTimer MainGameTimer;
    [FieldOffset(1724)]
    public fixed Int32 TeamScore[2];
    public readonly FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 184, 6); }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        hash = hash * 31 + (Int32)GameState;
        hash = hash * 31 + GameStateTimer.GetHashCode();
        hash = hash * 31 + MainGameTimer.GetHashCode();
        fixed (Int32* p = TeamScore) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet6.Serialize(&p->PlayerLastConnectionState, serializer);
        serializer.Stream.Serialize((Int32*)&p->GameState);
        serializer.Stream.SerializeBuffer(&p->TeamScore[0], 2);
        Quantum.CountdownTimer.Serialize(&p->GameStateTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->MainGameTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Union()]
  [ExcludeFromPrototype()]
  public unsafe partial struct QuantumThumbSticks {
    public const Int32 SIZE = 12;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(10)]
    private fixed Byte _alignment_padding_[2];
    [FieldOffset(0)]
    private Int32 _field_used_;
    [FieldOffset(4)]
    [FieldOverlap(4)]
    [FramePrinter.PrintIf("_field_used_", Quantum.QuantumThumbSticks.REGULAR)]
    private QuantumRegularThumbSticks _Regular;
    [FieldOffset(4)]
    [FieldOverlap(4)]
    [FramePrinter.PrintIf("_field_used_", Quantum.QuantumThumbSticks.HIGHRES)]
    private QuantumHighresThumbSticks _HighRes;
    public const Int32 REGULAR = 1;
    public const Int32 HIGHRES = 2;
    public readonly Int32 Field {
      get {
        return _field_used_;
      }
    }
    public QuantumRegularThumbSticks* Regular {
      get {
        fixed (QuantumRegularThumbSticks* p = &_Regular) {
          if (_field_used_ != REGULAR) {
            Native.Utils.Clear(p, 4);
            _field_used_ = REGULAR;
          }
          return p;
        }
      }
    }
    public QuantumHighresThumbSticks* HighRes {
      get {
        fixed (QuantumHighresThumbSticks* p = &_HighRes) {
          if (_field_used_ != HIGHRES) {
            Native.Utils.Clear(p, 6);
            _field_used_ = HIGHRES;
          }
          return p;
        }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 8867;
        hash = hash * 31 + _field_used_.GetHashCode();
        hash = hash * 31 + _Regular.GetHashCode();
        hash = hash * 31 + _HighRes.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumThumbSticks*)ptr;
        if (serializer.InputMode) {
          serializer.Stream.SerializeBuffer((byte*)p, Quantum.QuantumThumbSticks.SIZE);
          return;
        }
        serializer.Stream.Serialize(&p->_field_used_);
        if (p->_field_used_ == HIGHRES) {
          Quantum.QuantumHighresThumbSticks.Serialize(&p->_HighRes, serializer);
        }
        if (p->_field_used_ == REGULAR) {
          Quantum.QuantumRegularThumbSticks.Serialize(&p->_Regular, serializer);
        }
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AbilityInventory : Quantum.IComponent {
    public const Int32 SIZE = 984;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(888)]
    [ExcludeFromPrototype()]
    public ActiveAbilityInfo ActiveAbilityInfo;
    [FieldOffset(8)]
    [FramePrinter.FixedArrayAttribute(typeof(Ability), 11)]
    private fixed Byte _Abilities_[880];
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public QBoolean Blocking;
    public readonly FixedArray<Ability> Abilities {
      get {
        fixed (byte* p = _Abilities_) { return new FixedArray<Ability>(p, 80, 11); }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 13523;
        hash = hash * 31 + ActiveAbilityInfo.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(Abilities);
        hash = hash * 31 + Blocking.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AbilityInventory*)ptr;
        QBoolean.Serialize(&p->Blocking, serializer);
        FixedArray.Serialize(p->Abilities, serializer, Statics.SerializeAbility);
        Quantum.ActiveAbilityInfo.Serialize(&p->ActiveAbilityInfo, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BallSpawner : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 18121;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BallSpawner*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BallStatus : Quantum.IComponent {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public EntityRef HoldingPlayerEntityRef;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public CountdownTimer GravityChangeTimer;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public CountdownTimer CatchTimeoutTimer;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public PlayerRef CatchTimeoutPlayerRef;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QBoolean HasCollisionEnter;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean HasCollision;
    [FieldOffset(16)]
    public AssetRef<BallHandlingData> BallHandlingData;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 6101;
        hash = hash * 31 + HoldingPlayerEntityRef.GetHashCode();
        hash = hash * 31 + GravityChangeTimer.GetHashCode();
        hash = hash * 31 + CatchTimeoutTimer.GetHashCode();
        hash = hash * 31 + CatchTimeoutPlayerRef.GetHashCode();
        hash = hash * 31 + HasCollisionEnter.GetHashCode();
        hash = hash * 31 + HasCollision.GetHashCode();
        hash = hash * 31 + BallHandlingData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BallStatus*)ptr;
        PlayerRef.Serialize(&p->CatchTimeoutPlayerRef, serializer);
        QBoolean.Serialize(&p->HasCollision, serializer);
        QBoolean.Serialize(&p->HasCollisionEnter, serializer);
        AssetRef.Serialize(&p->BallHandlingData, serializer);
        EntityRef.Serialize(&p->HoldingPlayerEntityRef, serializer);
        Quantum.CountdownTimer.Serialize(&p->CatchTimeoutTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->GravityChangeTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BallTrajectoryState : Quantum.IComponent {
    public const Int32 SIZE = 800;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(32)]
    [FramePrinter.FixedArrayAttribute(typeof(FPVector3), 32)]
    private fixed Byte _Path_[768];
    [FieldOffset(0)]
    public Int32 PathCount;
    [FieldOffset(24)]
    public FP PathTotalLen;
    [FieldOffset(8)]
    public FP PathDist;
    [FieldOffset(16)]
    public FP PathSpeed;
    [FieldOffset(4)]
    public QBoolean Finished;
    public readonly FixedArray<FPVector3> Path {
      get {
        fixed (byte* p = _Path_) { return new FixedArray<FPVector3>(p, 24, 32); }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 3517;
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(Path);
        hash = hash * 31 + PathCount.GetHashCode();
        hash = hash * 31 + PathTotalLen.GetHashCode();
        hash = hash * 31 + PathDist.GetHashCode();
        hash = hash * 31 + PathSpeed.GetHashCode();
        hash = hash * 31 + Finished.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BallTrajectoryState*)ptr;
        serializer.Stream.Serialize(&p->PathCount);
        QBoolean.Serialize(&p->Finished, serializer);
        FP.Serialize(&p->PathDist, serializer);
        FP.Serialize(&p->PathSpeed, serializer);
        FP.Serialize(&p->PathTotalLen, serializer);
        FixedArray.Serialize(p->Path, serializer, Statics.SerializeFPVector3);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BananaTrapOwner : Quantum.IComponent {
    public const Int32 SIZE = 80;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public QBoolean Active;
    [FieldOffset(56)]
    public FPVector3 Pos;
    [FieldOffset(40)]
    public CountdownTimer Despawn;
    [FieldOffset(16)]
    public FP TriggerRadius;
    [FieldOffset(8)]
    public FP FallVelocity;
    [FieldOffset(4)]
    public QBoolean Armed;
    [FieldOffset(24)]
    public CountdownTimer ArmDelay;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17569;
        hash = hash * 31 + Active.GetHashCode();
        hash = hash * 31 + Pos.GetHashCode();
        hash = hash * 31 + Despawn.GetHashCode();
        hash = hash * 31 + TriggerRadius.GetHashCode();
        hash = hash * 31 + FallVelocity.GetHashCode();
        hash = hash * 31 + Armed.GetHashCode();
        hash = hash * 31 + ArmDelay.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BananaTrapOwner*)ptr;
        QBoolean.Serialize(&p->Active, serializer);
        QBoolean.Serialize(&p->Armed, serializer);
        FP.Serialize(&p->FallVelocity, serializer);
        FP.Serialize(&p->TriggerRadius, serializer);
        Quantum.CountdownTimer.Serialize(&p->ArmDelay, serializer);
        Quantum.CountdownTimer.Serialize(&p->Despawn, serializer);
        FPVector3.Serialize(&p->Pos, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BombState : Quantum.IComponent {
    public const Int32 SIZE = 872;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public EntityRef Owner;
    [FieldOffset(4)]
    public PlayerTeam OwnerTeam;
    [FieldOffset(104)]
    [FramePrinter.FixedArrayAttribute(typeof(FPVector3), 32)]
    private fixed Byte _Path_[768];
    [FieldOffset(0)]
    public Int32 PathCount;
    [FieldOffset(96)]
    public FP PathTotalLen;
    [FieldOffset(80)]
    public FP PathDist;
    [FieldOffset(88)]
    public FP PathSpeed;
    [FieldOffset(12)]
    public QBoolean Finished;
    [FieldOffset(64)]
    public FP HandoffDistance;
    [FieldOffset(40)]
    public FP DownwardBias;
    [FieldOffset(48)]
    public FP ExplosionRadius;
    [FieldOffset(72)]
    public FP LifeTimeLeft;
    [FieldOffset(56)]
    public FP GroundFuseLeft;
    [FieldOffset(32)]
    public FP ContactTriggerRadius;
    [FieldOffset(16)]
    public QBoolean GroundFuseArmed;
    [FieldOffset(8)]
    public QBoolean Exploded;
    public readonly FixedArray<FPVector3> Path {
      get {
        fixed (byte* p = _Path_) { return new FixedArray<FPVector3>(p, 24, 32); }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 15881;
        hash = hash * 31 + Owner.GetHashCode();
        hash = hash * 31 + (Int32)OwnerTeam;
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(Path);
        hash = hash * 31 + PathCount.GetHashCode();
        hash = hash * 31 + PathTotalLen.GetHashCode();
        hash = hash * 31 + PathDist.GetHashCode();
        hash = hash * 31 + PathSpeed.GetHashCode();
        hash = hash * 31 + Finished.GetHashCode();
        hash = hash * 31 + HandoffDistance.GetHashCode();
        hash = hash * 31 + DownwardBias.GetHashCode();
        hash = hash * 31 + ExplosionRadius.GetHashCode();
        hash = hash * 31 + LifeTimeLeft.GetHashCode();
        hash = hash * 31 + GroundFuseLeft.GetHashCode();
        hash = hash * 31 + ContactTriggerRadius.GetHashCode();
        hash = hash * 31 + GroundFuseArmed.GetHashCode();
        hash = hash * 31 + Exploded.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BombState*)ptr;
        serializer.Stream.Serialize(&p->PathCount);
        serializer.Stream.Serialize((Int32*)&p->OwnerTeam);
        QBoolean.Serialize(&p->Exploded, serializer);
        QBoolean.Serialize(&p->Finished, serializer);
        QBoolean.Serialize(&p->GroundFuseArmed, serializer);
        EntityRef.Serialize(&p->Owner, serializer);
        FP.Serialize(&p->ContactTriggerRadius, serializer);
        FP.Serialize(&p->DownwardBias, serializer);
        FP.Serialize(&p->ExplosionRadius, serializer);
        FP.Serialize(&p->GroundFuseLeft, serializer);
        FP.Serialize(&p->HandoffDistance, serializer);
        FP.Serialize(&p->LifeTimeLeft, serializer);
        FP.Serialize(&p->PathDist, serializer);
        FP.Serialize(&p->PathSpeed, serializer);
        FP.Serialize(&p->PathTotalLen, serializer);
        FixedArray.Serialize(p->Path, serializer, Statics.SerializeFPVector3);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerSpawner : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public PlayerRef PlayerRef;
    [FieldOffset(4)]
    public PlayerTeam PlayerTeam;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 18521;
        hash = hash * 31 + PlayerRef.GetHashCode();
        hash = hash * 31 + (Int32)PlayerTeam;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerSpawner*)ptr;
        PlayerRef.Serialize(&p->PlayerRef, serializer);
        serializer.Stream.Serialize((Int32*)&p->PlayerTeam);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerStatus : Quantum.IComponent {
    public const Int32 SIZE = 200;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public PlayerRef PlayerRef;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public EntityRef SpawnerEntityRef;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public PlayerTeam PlayerTeam;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public QBoolean HasAirJump;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public CountdownTimer JumpCoyoteTimer;
    [FieldOffset(80)]
    [ExcludeFromPrototype()]
    public CountdownTimer RespawnTimer;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public EntityRef HoldingBallEntityRef;
    [FieldOffset(24)]
    public AssetRef<PlayerMovementData> PlayerMovementData;
    [FieldOffset(112)]
    [Space()]
    public StatusEffect StunStatusEffect;
    [FieldOffset(128)]
    public KnockbackStatusEffect KnockbackStatusEffect;
    [FieldOffset(96)]
    public FPVector2 DropzoneDir01;
    [FieldOffset(8)]
    public QBoolean DropzoneHas;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public CountdownTimer ExternalSpeedster;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public QBoolean ExternalSpeedsterActive;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 6329;
        hash = hash * 31 + PlayerRef.GetHashCode();
        hash = hash * 31 + SpawnerEntityRef.GetHashCode();
        hash = hash * 31 + (Int32)PlayerTeam;
        hash = hash * 31 + HasAirJump.GetHashCode();
        hash = hash * 31 + JumpCoyoteTimer.GetHashCode();
        hash = hash * 31 + RespawnTimer.GetHashCode();
        hash = hash * 31 + HoldingBallEntityRef.GetHashCode();
        hash = hash * 31 + PlayerMovementData.GetHashCode();
        hash = hash * 31 + StunStatusEffect.GetHashCode();
        hash = hash * 31 + KnockbackStatusEffect.GetHashCode();
        hash = hash * 31 + DropzoneDir01.GetHashCode();
        hash = hash * 31 + DropzoneHas.GetHashCode();
        hash = hash * 31 + ExternalSpeedster.GetHashCode();
        hash = hash * 31 + ExternalSpeedsterActive.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerStatus*)ptr;
        PlayerRef.Serialize(&p->PlayerRef, serializer);
        serializer.Stream.Serialize((Int32*)&p->PlayerTeam);
        QBoolean.Serialize(&p->DropzoneHas, serializer);
        QBoolean.Serialize(&p->ExternalSpeedsterActive, serializer);
        QBoolean.Serialize(&p->HasAirJump, serializer);
        AssetRef.Serialize(&p->PlayerMovementData, serializer);
        EntityRef.Serialize(&p->HoldingBallEntityRef, serializer);
        EntityRef.Serialize(&p->SpawnerEntityRef, serializer);
        Quantum.CountdownTimer.Serialize(&p->ExternalSpeedster, serializer);
        Quantum.CountdownTimer.Serialize(&p->JumpCoyoteTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->RespawnTimer, serializer);
        FPVector2.Serialize(&p->DropzoneDir01, serializer);
        Quantum.StatusEffect.Serialize(&p->StunStatusEffect, serializer);
        Quantum.KnockbackStatusEffect.Serialize(&p->KnockbackStatusEffect, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SlowedStatusEffect : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public QBoolean IsActive;
    [FieldOffset(8)]
    public CountdownTimer Duration;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 21467;
        hash = hash * 31 + IsActive.GetHashCode();
        hash = hash * 31 + Duration.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SlowedStatusEffect*)ptr;
        QBoolean.Serialize(&p->IsActive, serializer);
        Quantum.CountdownTimer.Serialize(&p->Duration, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct StaticColliderLink : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 StaticColliderIndex;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 14713;
        hash = hash * 31 + StaticColliderIndex.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (StaticColliderLink*)ptr;
        serializer.Stream.Serialize(&p->StaticColliderIndex);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct TeamBaseWallStaticColliderTag : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 13901;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (TeamBaseWallStaticColliderTag*)ptr;
    }
  }
  public unsafe partial interface ISignalOnCooldownsReset : ISignal {
    void OnCooldownsReset(Frame f, EntityRef playerEntityRef);
  }
  public unsafe partial interface ISignalOnActiveAbilityStopped : ISignal {
    void OnActiveAbilityStopped(Frame f, EntityRef playerEntityRef);
  }
  public unsafe partial interface ISignalOnBallSpawned : ISignal {
    void OnBallSpawned(Frame f);
  }
  public unsafe partial interface ISignalOnBallRespawned : ISignal {
    void OnBallRespawned(Frame f, EntityRef ballEntityRef);
  }
  public unsafe partial interface ISignalOnBallDespawned : ISignal {
    void OnBallDespawned(Frame f, EntityRef ballEntityRef);
  }
  public unsafe partial interface ISignalOnBallReleased : ISignal {
    void OnBallReleased(Frame f, EntityRef ballEntityRef);
  }
  public unsafe partial interface ISignalOnBallDropped : ISignal {
    void OnBallDropped(Frame f, EntityRef ballEntityRef);
  }
  public unsafe partial interface ISignalOnBallPhysicsReset : ISignal {
    void OnBallPhysicsReset(Frame f, EntityRef ballEntityRef);
  }
  public unsafe partial interface ISignalOnGoalScored : ISignal {
    void OnGoalScored(Frame f, EntityRef playerEntityRef, PlayerTeam playerTeam);
  }
  public unsafe partial interface ISignalOnPlayerRespawned : ISignal {
    void OnPlayerRespawned(Frame f, EntityRef playerEntityRef, QBoolean fullReset);
  }
  public unsafe partial interface ISignalOnPlayerRespawnTimerReset : ISignal {
    void OnPlayerRespawnTimerReset(Frame f, EntityRef playerEntityRef);
  }
  public unsafe partial interface ISignalOnStunApplied : ISignal {
    void OnStunApplied(Frame f, EntityRef playerEntityRef, FP duration);
  }
  public unsafe partial interface ISignalOnKnockbackApplied : ISignal {
    void OnKnockbackApplied(Frame f, EntityRef playerEntityRef, FP duration, FPVector3 direction);
  }
  public unsafe partial interface ISignalOnStatusEffectsReset : ISignal {
    void OnStatusEffectsReset(Frame f, EntityRef playerEntityRef);
  }
  public static unsafe partial class Constants {
  }
  public unsafe partial class Frame {
    private ISignalOnCooldownsReset[] _ISignalOnCooldownsResetSystems;
    private ISignalOnActiveAbilityStopped[] _ISignalOnActiveAbilityStoppedSystems;
    private ISignalOnBallSpawned[] _ISignalOnBallSpawnedSystems;
    private ISignalOnBallRespawned[] _ISignalOnBallRespawnedSystems;
    private ISignalOnBallDespawned[] _ISignalOnBallDespawnedSystems;
    private ISignalOnBallReleased[] _ISignalOnBallReleasedSystems;
    private ISignalOnBallDropped[] _ISignalOnBallDroppedSystems;
    private ISignalOnBallPhysicsReset[] _ISignalOnBallPhysicsResetSystems;
    private ISignalOnGoalScored[] _ISignalOnGoalScoredSystems;
    private ISignalOnPlayerRespawned[] _ISignalOnPlayerRespawnedSystems;
    private ISignalOnPlayerRespawnTimerReset[] _ISignalOnPlayerRespawnTimerResetSystems;
    private ISignalOnStunApplied[] _ISignalOnStunAppliedSystems;
    private ISignalOnKnockbackApplied[] _ISignalOnKnockbackAppliedSystems;
    private ISignalOnStatusEffectsReset[] _ISignalOnStatusEffectsResetSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ISignalOnCooldownsResetSystems = BuildSignalsArray<ISignalOnCooldownsReset>();
      _ISignalOnActiveAbilityStoppedSystems = BuildSignalsArray<ISignalOnActiveAbilityStopped>();
      _ISignalOnBallSpawnedSystems = BuildSignalsArray<ISignalOnBallSpawned>();
      _ISignalOnBallRespawnedSystems = BuildSignalsArray<ISignalOnBallRespawned>();
      _ISignalOnBallDespawnedSystems = BuildSignalsArray<ISignalOnBallDespawned>();
      _ISignalOnBallReleasedSystems = BuildSignalsArray<ISignalOnBallReleased>();
      _ISignalOnBallDroppedSystems = BuildSignalsArray<ISignalOnBallDropped>();
      _ISignalOnBallPhysicsResetSystems = BuildSignalsArray<ISignalOnBallPhysicsReset>();
      _ISignalOnGoalScoredSystems = BuildSignalsArray<ISignalOnGoalScored>();
      _ISignalOnPlayerRespawnedSystems = BuildSignalsArray<ISignalOnPlayerRespawned>();
      _ISignalOnPlayerRespawnTimerResetSystems = BuildSignalsArray<ISignalOnPlayerRespawnTimerReset>();
      _ISignalOnStunAppliedSystems = BuildSignalsArray<ISignalOnStunApplied>();
      _ISignalOnKnockbackAppliedSystems = BuildSignalsArray<ISignalOnKnockbackApplied>();
      _ISignalOnStatusEffectsResetSystems = BuildSignalsArray<ISignalOnStatusEffectsReset>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<Quantum.AbilityInventory>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AbilityInventory>();
      BuildSignalsArrayOnComponentAdded<Quantum.BallSpawner>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BallSpawner>();
      BuildSignalsArrayOnComponentAdded<Quantum.BallStatus>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BallStatus>();
      BuildSignalsArrayOnComponentAdded<Quantum.BallTrajectoryState>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BallTrajectoryState>();
      BuildSignalsArrayOnComponentAdded<Quantum.BananaTrapOwner>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BananaTrapOwner>();
      BuildSignalsArrayOnComponentAdded<Quantum.BombState>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BombState>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerSpawner>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerSpawner>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerStatus>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerStatus>();
      BuildSignalsArrayOnComponentAdded<Quantum.SlowedStatusEffect>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SlowedStatusEffect>();
      BuildSignalsArrayOnComponentAdded<Quantum.StaticColliderLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.StaticColliderLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.TeamBaseWallStaticColliderTag>();
      BuildSignalsArrayOnComponentRemoved<Quantum.TeamBaseWallStaticColliderTag>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->_left = i->_left.Update(this.Number, input._left);
      i->_right = i->_right.Update(this.Number, input._right);
      i->_up = i->_up.Update(this.Number, input._up);
      i->_down = i->_down.Update(this.Number, input._down);
      i->_a = i->_a.Update(this.Number, input._a);
      i->_b = i->_b.Update(this.Number, input._b);
      i->_c = i->_c.Update(this.Number, input._c);
      i->_d = i->_d.Update(this.Number, input._d);
      i->_l1 = i->_l1.Update(this.Number, input._l1);
      i->_l2 = i->_l2.Update(this.Number, input._l2);
      i->_r1 = i->_r1.Update(this.Number, input._r1);
      i->_select = i->_select.Update(this.Number, input._select);
      i->_start = i->_start.Update(this.Number, input._start);
      i->_r2 = i->_r2.Update(this.Number, input._r2);
      i->_analogRightTrigger = input._analogRightTrigger;
      i->_analogLeftTrigger = input._analogLeftTrigger;
      i->ThumbSticks = input.ThumbSticks;
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      Physics2D?.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      Physics3D?.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
      public void OnCooldownsReset(EntityRef playerEntityRef) {
        var array = _f._ISignalOnCooldownsResetSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCooldownsReset(_f, playerEntityRef);
          }
        }
      }
      public void OnActiveAbilityStopped(EntityRef playerEntityRef) {
        var array = _f._ISignalOnActiveAbilityStoppedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnActiveAbilityStopped(_f, playerEntityRef);
          }
        }
      }
      public void OnBallSpawned() {
        var array = _f._ISignalOnBallSpawnedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnBallSpawned(_f);
          }
        }
      }
      public void OnBallRespawned(EntityRef ballEntityRef) {
        var array = _f._ISignalOnBallRespawnedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnBallRespawned(_f, ballEntityRef);
          }
        }
      }
      public void OnBallDespawned(EntityRef ballEntityRef) {
        var array = _f._ISignalOnBallDespawnedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnBallDespawned(_f, ballEntityRef);
          }
        }
      }
      public void OnBallReleased(EntityRef ballEntityRef) {
        var array = _f._ISignalOnBallReleasedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnBallReleased(_f, ballEntityRef);
          }
        }
      }
      public void OnBallDropped(EntityRef ballEntityRef) {
        var array = _f._ISignalOnBallDroppedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnBallDropped(_f, ballEntityRef);
          }
        }
      }
      public void OnBallPhysicsReset(EntityRef ballEntityRef) {
        var array = _f._ISignalOnBallPhysicsResetSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnBallPhysicsReset(_f, ballEntityRef);
          }
        }
      }
      public void OnGoalScored(EntityRef playerEntityRef, PlayerTeam playerTeam) {
        var array = _f._ISignalOnGoalScoredSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnGoalScored(_f, playerEntityRef, playerTeam);
          }
        }
      }
      public void OnPlayerRespawned(EntityRef playerEntityRef, QBoolean fullReset) {
        var array = _f._ISignalOnPlayerRespawnedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnPlayerRespawned(_f, playerEntityRef, fullReset);
          }
        }
      }
      public void OnPlayerRespawnTimerReset(EntityRef playerEntityRef) {
        var array = _f._ISignalOnPlayerRespawnTimerResetSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnPlayerRespawnTimerReset(_f, playerEntityRef);
          }
        }
      }
      public void OnStunApplied(EntityRef playerEntityRef, FP duration) {
        var array = _f._ISignalOnStunAppliedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnStunApplied(_f, playerEntityRef, duration);
          }
        }
      }
      public void OnKnockbackApplied(EntityRef playerEntityRef, FP duration, FPVector3 direction) {
        var array = _f._ISignalOnKnockbackAppliedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnKnockbackApplied(_f, playerEntityRef, duration, direction);
          }
        }
      }
      public void OnStatusEffectsReset(EntityRef playerEntityRef) {
        var array = _f._ISignalOnStatusEffectsResetSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnStatusEffectsReset(_f, playerEntityRef);
          }
        }
      }
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializeAbility;
    public static FrameSerializer.Delegate SerializeFPVector3;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitStaticDelegatesGen() {
      SerializeAbility = Quantum.Ability.Serialize;
      SerializeFPVector3 = FPVector3.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(Quantum.Ability), Quantum.Ability.SIZE);
      typeRegistry.Register(typeof(Quantum.AbilityAvailabilityType), 4);
      typeRegistry.Register(typeof(Quantum.AbilityInventory), Quantum.AbilityInventory.SIZE);
      typeRegistry.Register(typeof(Quantum.AbilityType), 4);
      typeRegistry.Register(typeof(Quantum.ActiveAbilityInfo), Quantum.ActiveAbilityInfo.SIZE);
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.BallSpawner), Quantum.BallSpawner.SIZE);
      typeRegistry.Register(typeof(Quantum.BallStatus), Quantum.BallStatus.SIZE);
      typeRegistry.Register(typeof(Quantum.BallTrajectoryState), Quantum.BallTrajectoryState.SIZE);
      typeRegistry.Register(typeof(Quantum.BananaTrapOwner), Quantum.BananaTrapOwner.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet6), Quantum.BitSet6.SIZE);
      typeRegistry.Register(typeof(Quantum.BombState), Quantum.BombState.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(CallbackFlags), 4);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(Quantum.CountdownTimer), Quantum.CountdownTimer.SIZE);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.GameState), 4);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(InputDirection), InputDirection.SIZE);
      typeRegistry.Register(typeof(InputDirectionMagnitude), InputDirectionMagnitude.SIZE);
      typeRegistry.Register(typeof(InputPitchYaw), InputPitchYaw.SIZE);
      typeRegistry.Register(typeof(IntVector2), IntVector2.SIZE);
      typeRegistry.Register(typeof(IntVector3), IntVector3.SIZE);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.KnockbackStatusEffect), Quantum.KnockbackStatusEffect.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerSpawner), Quantum.PlayerSpawner.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerStatus), Quantum.PlayerStatus.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerTeam), 4);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumDemoInputPlatformer2D), Quantum.QuantumDemoInputPlatformer2D.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumDemoInputShooter3D), Quantum.QuantumDemoInputShooter3D.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumDemoInputTopDown), Quantum.QuantumDemoInputTopDown.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumHighresThumbSticks), Quantum.QuantumHighresThumbSticks.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumRegularThumbSticks), Quantum.QuantumRegularThumbSticks.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumThumbSticks), Quantum.QuantumThumbSticks.SIZE);
      typeRegistry.Register(typeof(QueryOptions), 2);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Quantum.SelectedAbilities), Quantum.SelectedAbilities.SIZE);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(Quantum.SlowedStatusEffect), Quantum.SlowedStatusEffect.SIZE);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.StaticColliderLink), Quantum.StaticColliderLink.SIZE);
      typeRegistry.Register(typeof(Quantum.StatusEffect), Quantum.StatusEffect.SIZE);
      typeRegistry.Register(typeof(Quantum.StatusEffectConfig), Quantum.StatusEffectConfig.SIZE);
      typeRegistry.Register(typeof(Quantum.StatusEffectType), 4);
      typeRegistry.Register(typeof(Quantum.TeamBaseWallStaticColliderTag), Quantum.TeamBaseWallStaticColliderTag.SIZE);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 11)
        .AddBuiltInComponents()
        .Add<Quantum.AbilityInventory>(Quantum.AbilityInventory.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.BallSpawner>(Quantum.BallSpawner.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.BallStatus>(Quantum.BallStatus.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.BallTrajectoryState>(Quantum.BallTrajectoryState.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.BananaTrapOwner>(Quantum.BananaTrapOwner.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.BombState>(Quantum.BombState.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerSpawner>(Quantum.PlayerSpawner.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerStatus>(Quantum.PlayerStatus.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.SlowedStatusEffect>(Quantum.SlowedStatusEffect.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.StaticColliderLink>(Quantum.StaticColliderLink.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.TeamBaseWallStaticColliderTag>(Quantum.TeamBaseWallStaticColliderTag.Serialize, null, null, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AbilityAvailabilityType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AbilityType>();
      FramePrinter.EnsurePrimitiveNotStripped<CallbackFlags>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.GameState>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PlayerTeam>();
      FramePrinter.EnsurePrimitiveNotStripped<QueryOptions>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.StatusEffectType>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
